package com.salvadormontiel.cable.compiler.writer;

import com.salvadormontiel.cable.CableRequest;
import com.salvadormontiel.cable.Component;
import com.salvadormontiel.cable.compiler.Registry;
import com.salvadormontiel.cable.compiler.element.ComponentElement;
import com.salvadormontiel.cable.compiler.element.WiredElement;
import com.salvadormontiel.cable.compiler.util.Util;
import com.salvadormontiel.cable.internal.AdapterHolder;
import com.salvadormontiel.cable.internal.ComponentAdapter;
import com.squareup.javapoet.*;

import javax.lang.model.type.TypeMirror;
import java.io.IOException;
import java.io.Writer;
import java.util.*;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static javax.lang.model.element.Modifier.*;

/**
 * @author Salvador Montiel
 */
public class ComponentWriter implements SourceWriter<ComponentElement> {
    private final Registry registry;

    public ComponentWriter(Registry registry) {
        this.registry = registry;
    }

    @Override
    public String createSourceName(ComponentElement element) {
        return element.getQualifiedName();
    }

    @Override
    public void writeSource(Writer writer, ComponentElement element) throws IOException {
        TypeName superInterface = ParameterizedTypeName.get(ClassName.get(ComponentAdapter.class),
            ClassName.get(element.getComponentPackage(), element.getComponentClassName()));
        //TypeName classTypeName = ParameterizedTypeName.get(ClassName.get(Supplier.class), ClassName.get(Object.class));
        TypeName classTypeName = ParameterizedTypeName.get(ClassName.get(Function.class), ParameterizedTypeName.get(ClassName.get(List.class), ClassName.get(Object.class)), ClassName.get(Object.class));
        TypeName mapTypeName = ParameterizedTypeName.get(ClassName.get(Map.class), ClassName.get(String.class), classTypeName);
        TypeSpec.Builder clazz = TypeSpec.classBuilder(element.getName())
                .addModifiers(PUBLIC, FINAL)
                .addSuperinterface(superInterface)
                .addField(FieldSpec.builder(TypeVariableName.get(element.getComponentClassName()), "component", PRIVATE).build())
                .addField(FieldSpec.builder(mapTypeName, "METHODS", PRIVATE, STATIC, FINAL)
                        .initializer("new $T<>()", HashMap.class)
                        .build()
                )
                /*.addField(FieldSpec.builder(mapTypeName2, "METHODS", PRIVATE, STATIC, FINAL)
                        .initializer("new $T<>()", HashMap.class)
                        .build()
                )*/
                .addMethod(constructor(element))
                .addMethod(handleMethod(element))
                .addMethod(getComponentMethod(element))
                .addMethod(setComponentMethod(element))
                .addMethod(getComponentNameMethod(element))
                .addMethod(resetMethod(element))
                .addMethod(getMethodCallMethod(element))
                .addMethod(getDataMethod(element))
                .addMethod(getReadonlyFieldsMethod(element));

        /*element.getWiredElements().stream()
                .filter(e -> !e.isField())
                .forEach(wiredElement -> {
                    clazz.addMethod(MethodSpec.methodBuilder(wiredElement.getName())
                            .addModifiers(PUBLIC)
                            .addStatement("component.$L()", wiredElement.getName())
                            .build());
                });*/

        JavaFile javaFile = JavaFile
            .builder(AdapterHolder.IMPL_CLASS_PACKAGE, clazz.build())
            .addFileComment("Generated by Cable. Do not modify!")
            .indent("    ")
            .build();
        javaFile.writeTo(writer);
    }

    private MethodSpec constructor(ComponentElement element) {
        CodeBlock.Builder cb = CodeBlock.builder();
        element.getWiredElements().stream()
                .filter(wiredElement -> !wiredElement.isField())
                .forEach(we -> {
                    String map = "METHODS";
                    TypeName tn = ParameterizedTypeName.get(ClassName.get(Function.class), ParameterizedTypeName.get(ClassName.get(List.class), ClassName.get(Object.class)), ClassName.get(Object.class));
                    String rt = "Object apply";

                    List<String> paramsList = new ArrayList<>();
                    int i = 0;
                    for (TypeMirror tm : we.getParameters()) {
                        paramsList.add("(" + tm + ") params.get(" + i + ")");
                        i++;
                    }

                    String params = String.join(", ", paramsList);
                    String xx = "return component." + we.getName() + "(" + params + ");\n";
                    System.out.println("___"+we.getDeserializedType());
                    if (we.getDeserializedType() != null
                            && we.getDeserializedType().equals(registry.getElements().getTypeElement("java.lang.Void"))) {
                        xx = "component." + we.getName() + "(" + params + ");\n    return new NullObject();\n";
                    }
                    cb.addStatement("$L.put($S, new $T() {\n" +
                                    "@Override\n" +
                                    "public $L(List<Object> params) {\n" +
                                    "    " + xx +
                                    "}})", map, we.getName(), tn, rt);
                });

        return MethodSpec.constructorBuilder()
                .addModifiers(PUBLIC)
                .addCode(cb.build())
                .build();
//        return MethodSpec.constructorBuilder()
//                .addModifiers(PUBLIC)
//                .addParameter(TypeVariableName.get(element.getComponentClassName()), "component")
//                .addStatement("this.component = component")
//                .build();
    }

    private MethodSpec handleMethod(ComponentElement element) {
        CodeBlock.Builder stmts = CodeBlock.builder();
        element.getWiredElements().stream()
                .filter(WiredElement::isField)
                .filter(we -> !we.isReadOnly())
                .forEach(wiredElement -> {
                    stmts.beginControlFlow("if (input.changes($S) != null)", wiredElement.getName())
                            .addStatement("this.component.$L = input.changes($S)", wiredElement.getName(), wiredElement.getName())
                            .nextControlFlow("else if (input.state($S) != null)", wiredElement.getName())
                            .addStatement("this.component.$L = input.state($S)", wiredElement.getName(), wiredElement.getName())
                            .endControlFlow();
                });

        TypeName returns = TypeVariableName.get(element.getComponentClassName() + Util.getComponentSuffix());
        return MethodSpec.methodBuilder("handle")
                .addModifiers(PUBLIC)
                .addAnnotation(Override.class)
                .addParameter(ParameterSpec.builder(CableRequest.class, "input").build())
                .addParameter(ParameterSpec.builder(String.class, "target").build())
                .addCode(stmts.build())
                //.addStatement("return new $T(state, new $T())", returns, TypeVariableName.get(element.getComponentClassName()))
                //.returns(returns)
                .build();
    }

    private MethodSpec getComponentMethod(ComponentElement element) {
        return MethodSpec.methodBuilder("getComponent")
                .addAnnotation(Override.class)
                .addModifiers(PUBLIC)
                .returns(TypeVariableName.get(element.getComponentClassName()))
                .addStatement("return component")
                .build();
    }

    private MethodSpec setComponentMethod(ComponentElement element) {
        return MethodSpec.methodBuilder("setComponent")
                .addModifiers(PUBLIC)
                .addAnnotation(Override.class)
                .addParameter(TypeVariableName.get(element.getComponentClassName()), "component")
                .addStatement("this.component = component")
                .build();
    }

    private MethodSpec getComponentNameMethod(ComponentElement element) {
        return MethodSpec.methodBuilder("getComponentName")
                .addModifiers(PUBLIC)
                .returns(String.class)
                .addStatement("return $S", element.getComponentName())
                .build();
    }

    private MethodSpec resetMethod(ComponentElement element) {
        CodeBlock.Builder cb = CodeBlock.builder();
        element.getWiredElements().stream()
                .filter(WiredElement::isField)
                .forEach(we -> cb.addStatement("component." + we.getName() + " = null"));
        return MethodSpec.methodBuilder("reset")
                .addModifiers(PUBLIC)
                .addAnnotation(Override.class)
                .addCode(cb.build())
                .build();
    }

    private MethodSpec getMethodCallMethod(ComponentElement element) {
//        TypeName returns = ParameterizedTypeName.get(ClassName.get(Supplier.class), ClassName.get(Object.class));
        TypeName returns = ParameterizedTypeName.get(ClassName.get(Function.class), ParameterizedTypeName.get(ClassName.get(List.class), ClassName.get(Object.class)), ClassName.get(Object.class));

        return MethodSpec.methodBuilder("getMethodCall")
                .addModifiers(PUBLIC)
                .addAnnotation(Override.class)
                .addParameter(ClassName.get(String.class), "methodName")
                .addStatement("return METHODS.get(methodName)")
                .returns(returns)
                .build();
    }

    private MethodSpec getDataMethod(ComponentElement element) {
        TypeName returns = ParameterizedTypeName.get(ClassName.get(Map.class), ClassName.get(String.class), ClassName.get(Object.class));

        MethodSpec.Builder mb = MethodSpec.methodBuilder("getData")
                .addModifiers(PUBLIC)
                .addAnnotation(Override.class)
                .addStatement("Map<String, Object> m = new HashMap<>()")
                //.addStatement("return $T.singletonMap(\"\", \"\")", ClassName.get(Collections.class))
                .returns(returns);
        element.getWiredElements().stream()
                .filter(WiredElement::isField)
        .forEach(we -> {
            mb.addStatement("m.put($S, component.$L)", we.getName(), we.getName());
        });
        mb.addStatement("return m");

        return mb.build();
    }

    private MethodSpec getReadonlyFieldsMethod(ComponentElement element) {
        TypeName returns = ParameterizedTypeName.get(ClassName.get(List.class), ClassName.get(String.class));
        StringBuilder sb = new StringBuilder();
        String f = element.getWiredElements().stream()
                .filter(WiredElement::isField)
                .filter(WiredElement::isReadOnly)
                .map(we -> "\"" + we.getName() + "\"")
                .collect(Collectors.joining(", "));

        return MethodSpec.methodBuilder("getReadonlyFields")
                .addModifiers(PUBLIC)
                .addAnnotation(Override.class)
                .addStatement("return $T.asList(" + f + ")", ClassName.get(Arrays.class))
                .returns(returns)
                .build();
    }
/*
    private MethodSpec whereMethod(ComponentElement element) {
        return MethodSpec.methodBuilder("where")
            .addModifiers(PUBLIC, STATIC)
            .addParameter(ParameterSpec.builder(String.class, "column").build())
            .addParameter(ParameterSpec.builder(Object.class, "value").build())
            .returns(ParameterizedTypeName.get(ClassName.get(List.class), TypeVariableName.get(element.getModelName())))
            .addStatement("String sql = $T.columns(getColumnNamesWithAlias()).from(getComponentName()).where(column, value).getSql()", Select.class)
            .addStatement("return hydrate($T.execute(sql, getColumnAliases(), getColumnTypes()))", Database.class)
            .build();
    }

    private MethodSpec hydrateMethod(ComponentElement element) {
        List<String> columnNames = element.getColumns().stream()
            .map(ColumnElement::getColumnName)
            .collect(Collectors.toList());

        List<String> fieldNames = element.getColumns().stream()
            .map(ColumnElement::getFieldName)
            .collect(Collectors.toList());

        List<String> types = element.getColumns().stream()
            .map(ce -> ce.getDeserializedType().getSimpleName().toString())
            .collect(Collectors.toList());

        TypeName mapTypeName = ParameterizedTypeName.get(Map.class, String.class, Object.class);
        ParameterSpec param = ParameterSpec.builder(mapTypeName, "map").build();

        MethodSpec.Builder hydrateMethod = MethodSpec.methodBuilder("hydrate")
            .addModifiers(STATIC)
            .addParameter(param)
            .returns(TypeVariableName.get(element.getModelName()))
            .addStatement("$L model = new $L()", element.getModelName(), element.getModelName());
        for (int i = 0; i < columnNames.size(); i++) {
            //hydrateMethod.addStatement("model.$L = ($L) map.get(\"$L_$L\")",
            //    fieldNames.get(i), types.get(i), element.getComponentName(), columnNames.get(i));
            hydrateMethod.addStatement("model.$L = $L.valueOf(map.get(\"$L_$L\").toString())",
                fieldNames.get(i), types.get(i), element.getComponentName(), columnNames.get(i));
        }
        hydrateMethod.addStatement("return model");

        return hydrateMethod.build();
    }

    private MethodSpec hydrateListMethod(ComponentElement element) {
        TypeName mapTypeName = ParameterizedTypeName.get(Map.class, String.class, Object.class);
        TypeName listTypeName = ParameterizedTypeName.get(ClassName.get(List.class), mapTypeName);
        ParameterSpec param = ParameterSpec.builder(listTypeName, "list").build();

        return MethodSpec.methodBuilder("hydrate")
            .addModifiers(STATIC)
            .addParameter(param)
            .returns(ParameterizedTypeName.get(ClassName.get(List.class), TypeVariableName.get(element.getModelName())))
            .addStatement("return list.stream().map($L::hydrate).collect($T.toList())", element.getName(), Collectors.class)
            .build();
    }

    private MethodSpec getColumnNamesWithAliasMethod(ComponentElement element) {
        String columnNames = element.getColumns().stream()
            .map(ColumnElement::getColumnName)
            .map(cn -> element.getComponentName() + "." + cn + " AS " + element.getComponentName() + "_" + cn)
            .collect(Collectors.joining(","));

        return MethodSpec.methodBuilder("getColumnNamesWithAlias")
            .addModifiers(STATIC)
            .returns(ParameterizedTypeName.get(List.class, String.class))
            .addStatement("String columnNames = $S", columnNames)
            .addStatement("return $T.asList(columnNames.split($S))", Arrays.class, ",")
            .build();
    }

    private MethodSpec getColumnAliasesMethod(ComponentElement element) {
        String columnAliases = element.getColumns().stream()
            .map(ColumnElement::getColumnName)
            .map(cn -> element.getComponentName() + "_" + cn)
            .collect(Collectors.joining(","));

        return MethodSpec.methodBuilder("getColumnAliases")
            .addModifiers(STATIC)
            .returns(ParameterizedTypeName.get(List.class, String.class))
            .addStatement("String columnAliases = $S", columnAliases)
            .addStatement("return $T.asList(columnAliases.split($S))", Arrays.class, ",")
            .build();
    }

    private MethodSpec getColumnTypesMethod(ComponentElement element) {
        String columnTypes = element.getColumns().stream()
            .map(ColumnElement::getDeserializedType)
            .map(t -> t.getQualifiedName().toString())
            .collect(Collectors.joining(","));

        return MethodSpec.methodBuilder("getColumnTypes")
            .addModifiers(STATIC)
            .returns(ParameterizedTypeName.get(List.class, Class.class))
            .addStatement("String columnTypes = $S", columnTypes)
            .addStatement(CodeBlock.builder()
                .add("return Arrays.asList(columnTypes.split(\",\")).stream().map(t -> {\n")
                .add("    try {\n")
                .add("        return Class.forName(t);\n")
                .add("    } catch (ClassNotFoundException e) {\n")
                .add("        e.printStackTrace();\n")
                .add("        throw new RuntimeException(e);\n")
                .add("    }\n")
                .add("}).collect(Collectors.toList())")
                .build())
            .build();
    }*/
}
