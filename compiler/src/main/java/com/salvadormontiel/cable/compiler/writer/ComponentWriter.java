package com.salvadormontiel.cable.compiler.writer;

import com.salvadormontiel.cable.CableRequest;
import com.salvadormontiel.cable.compiler.Registry;
import com.salvadormontiel.cable.compiler.element.ComponentElement;
import com.salvadormontiel.cable.compiler.element.WiredElement;
import com.salvadormontiel.cable.compiler.util.Util;
import com.salvadormontiel.cable.internal.AdapterHolder;
import com.salvadormontiel.cable.internal.ComponentAdapter;
import com.squareup.javapoet.*;

import javax.lang.model.type.TypeMirror;
import java.io.IOException;
import java.io.Writer;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

import static javax.lang.model.element.Modifier.*;

/**
 * @author Salvador Montiel
 */
public class ComponentWriter implements SourceWriter<ComponentElement> {
    private final Registry registry;

    public ComponentWriter(Registry registry) {
        this.registry = registry;
    }

    @Override
    public String createSourceName(ComponentElement element) {
        return element.getQualifiedName();
    }

    @Override
    public void writeSource(Writer writer, ComponentElement element) throws IOException {
        TypeName superInterface = ParameterizedTypeName.get(ClassName.get(ComponentAdapter.class),
            ClassName.get(element.getComponentPackage(), element.getComponentClassName()));
        //TypeName classTypeName = ParameterizedTypeName.get(ClassName.get(Supplier.class), ClassName.get(Object.class));
        TypeName classTypeName = ParameterizedTypeName.get(ClassName.get(Function.class), ParameterizedTypeName.get(ClassName.get(List.class), ClassName.get(Object.class)), ClassName.get(Object.class));
        TypeName mapTypeName = ParameterizedTypeName.get(ClassName.get(Map.class), ClassName.get(String.class), classTypeName);
        TypeSpec.Builder clazz = TypeSpec.classBuilder(element.getName())
                .addModifiers(PUBLIC, FINAL)
                .addSuperinterface(superInterface)
                .addField(FieldSpec.builder(TypeVariableName.get(element.getComponentClassName()), "component", PRIVATE).build())
                .addField(FieldSpec.builder(mapTypeName, "METHODS", PRIVATE, STATIC, FINAL)
                        .initializer("new $T<>()", HashMap.class)
                        .build()
                )
                /*.addField(FieldSpec.builder(mapTypeName2, "METHODS", PRIVATE, STATIC, FINAL)
                        .initializer("new $T<>()", HashMap.class)
                        .build()
                )*/
                .addMethod(constructor(element))
                .addMethod(handleMethod(element))
                .addMethod(getComponentMethod(element))
                .addMethod(setComponentMethod(element))
                .addMethod(getComponentNameMethod(element))
                .addMethod(resetAllMethod(element))
                .addMethod(resetMethod(element))
                .addMethod(getMethodCallMethod(element))
                .addMethod(getDataMethod(element))
                .addMethod(getReadonlyFieldsMethod(element));

        /*element.getWiredElements().stream()
                .filter(e -> !e.isField())
                .forEach(wiredElement -> {
                    clazz.addMethod(MethodSpec.methodBuilder(wiredElement.getName())
                            .addModifiers(PUBLIC)
                            .addStatement("component.$L()", wiredElement.getName())
                            .build());
                });*/

        JavaFile javaFile = JavaFile
            .builder(AdapterHolder.IMPL_CLASS_PACKAGE, clazz.build())
            .addFileComment("Generated by Cable. Do not modify!")
            .indent("    ")
            .build();
        javaFile.writeTo(writer);
    }

    private MethodSpec constructor(ComponentElement element) {
        CodeBlock.Builder cb = CodeBlock.builder();
        element.getWiredElements().stream()
                .filter(wiredElement -> !wiredElement.isField())
                .forEach(we -> {
                    String map = "METHODS";
                    TypeName tn = ParameterizedTypeName.get(ClassName.get(Function.class), ParameterizedTypeName.get(ClassName.get(List.class), ClassName.get(Object.class)), ClassName.get(Object.class));
                    String rt = "Object apply";

                    List<String> paramsList = new ArrayList<>();
                    int i = 0;
                    for (TypeMirror tm : we.getParameters()) {
                        paramsList.add("(" + tm + ") params.get(" + i + ")");
                        i++;
                    }

                    String params = String.join(", ", paramsList);
                    String xx = "return component." + we.getName() + "(" + params + ");\n";
                    System.out.println("___"+we.getDeserializedType());
                    if (we.getDeserializedType() != null
                            && we.getDeserializedType().equals(registry.getElements().getTypeElement("java.lang.Void"))) {
                        xx = "component." + we.getName() + "(" + params + ");\n    return new NullObject();\n";
                    }
                    cb.addStatement("$L.put($S, new $T() {\n" +
                                    "@Override\n" +
                                    "public $L(List<Object> params) {\n" +
                                    "    " + xx +
                                    "}})", map, we.getName(), tn, rt);
                });

        return MethodSpec.constructorBuilder()
                .addModifiers(PUBLIC)
                .addCode(cb.build())
                .build();
//        return MethodSpec.constructorBuilder()
//                .addModifiers(PUBLIC)
//                .addParameter(TypeVariableName.get(element.getComponentClassName()), "component")
//                .addStatement("this.component = component")
//                .build();
    }

    private MethodSpec handleMethod(ComponentElement element) {
        CodeBlock.Builder stmts = CodeBlock.builder();
        element.getWiredElements().stream()
                .filter(WiredElement::isField)
                .filter(we -> !we.isReadOnly())
                .forEach(wiredElement -> {
                    stmts.beginControlFlow("if (input.changes($S) != null)", wiredElement.getName())
                            .addStatement("this.component.$L = input.changes($S)", wiredElement.getName(), wiredElement.getName())
                            .nextControlFlow("else if (input.state($S) != null)", wiredElement.getName())
                            .addStatement("this.component.$L = input.state($S)", wiredElement.getName(), wiredElement.getName())
                            .endControlFlow();
                });

        TypeName returns = TypeVariableName.get(element.getComponentClassName() + Util.getComponentSuffix());
        return MethodSpec.methodBuilder("handle")
                .addModifiers(PUBLIC)
                .addAnnotation(Override.class)
                .addParameter(ParameterSpec.builder(CableRequest.class, "input").build())
                .addParameter(ParameterSpec.builder(String.class, "target").build())
                .addCode(stmts.build())
                //.addStatement("return new $T(state, new $T())", returns, TypeVariableName.get(element.getComponentClassName()))
                //.returns(returns)
                .build();
    }

    private MethodSpec getComponentMethod(ComponentElement element) {
        return MethodSpec.methodBuilder("getComponent")
                .addAnnotation(Override.class)
                .addModifiers(PUBLIC)
                .returns(TypeVariableName.get(element.getComponentClassName()))
                .addStatement("return component")
                .build();
    }

    private MethodSpec setComponentMethod(ComponentElement element) {
        return MethodSpec.methodBuilder("setComponent")
                .addModifiers(PUBLIC)
                .addAnnotation(Override.class)
                .addParameter(TypeVariableName.get(element.getComponentClassName()), "component")
                .addStatement("this.component = component")
                .build();
    }

    private MethodSpec getComponentNameMethod(ComponentElement element) {
        return MethodSpec.methodBuilder("getComponentName")
                .addModifiers(PUBLIC)
                .returns(String.class)
                .addStatement("return $S", element.getComponentName())
                .build();
    }

    private MethodSpec resetAllMethod(ComponentElement element) {
        CodeBlock.Builder cb = CodeBlock.builder();
        element.getWiredElements().stream()
                .filter(WiredElement::isField)
                .forEach(we -> cb.addStatement("component." + we.getName() + " = null"));
        return MethodSpec.methodBuilder("resetAll")
                .addModifiers(PUBLIC)
                .addAnnotation(Override.class)
                .addCode(cb.build())
                .build();
    }

    private MethodSpec resetMethod(ComponentElement element) {
        CodeBlock.Builder cb = CodeBlock.builder();
        element.getWiredElements().stream()
                .filter(WiredElement::isField)
                .forEach(we -> {
                    cb.beginControlFlow("if (fieldNames.contains(component." + we.getName() + "))");
                    cb.addStatement("component." + we.getName() + " = null");
                    cb.endControlFlow();
                });
        return MethodSpec.methodBuilder("reset")
                .addModifiers(PUBLIC)
                .addAnnotation(Override.class)
                .addParameter(ParameterizedTypeName.get(ClassName.get(List.class), ClassName.get(String.class)), "fieldNames")
                .addCode(cb.build())
                .build();
    }

    private MethodSpec getMethodCallMethod(ComponentElement element) {
//        TypeName returns = ParameterizedTypeName.get(ClassName.get(Supplier.class), ClassName.get(Object.class));
        TypeName returns = ParameterizedTypeName.get(ClassName.get(Function.class), ParameterizedTypeName.get(ClassName.get(List.class), ClassName.get(Object.class)), ClassName.get(Object.class));

        return MethodSpec.methodBuilder("getMethodCall")
                .addModifiers(PUBLIC)
                .addAnnotation(Override.class)
                .addParameter(ClassName.get(String.class), "methodName")
                .addStatement("return METHODS.get(methodName)")
                .returns(returns)
                .build();
    }

    private MethodSpec getDataMethod(ComponentElement element) {
        TypeName returns = ParameterizedTypeName.get(ClassName.get(Map.class), ClassName.get(String.class), ClassName.get(Object.class));

        MethodSpec.Builder mb = MethodSpec.methodBuilder("getData")
                .addModifiers(PUBLIC)
                .addAnnotation(Override.class)
                .addStatement("Map<String, Object> m = new HashMap<>()")
                //.addStatement("return $T.singletonMap(\"\", \"\")", ClassName.get(Collections.class))
                .returns(returns);
        element.getWiredElements().stream()
                .filter(WiredElement::isField)
        .forEach(we -> {
            mb.addStatement("m.put($S, component.$L)", we.getName(), we.getName());
        });
        mb.addStatement("return m");

        return mb.build();
    }

    private MethodSpec getReadonlyFieldsMethod(ComponentElement element) {
        TypeName returns = ParameterizedTypeName.get(ClassName.get(List.class), ClassName.get(String.class));
        StringBuilder sb = new StringBuilder();
        String f = element.getWiredElements().stream()
                .filter(WiredElement::isField)
                .filter(WiredElement::isReadOnly)
                .map(we -> "\"" + we.getName() + "\"")
                .collect(Collectors.joining(", "));

        return MethodSpec.methodBuilder("getReadonlyFields")
                .addModifiers(PUBLIC)
                .addAnnotation(Override.class)
                .addStatement("return $T.asList(" + f + ")", ClassName.get(Arrays.class))
                .returns(returns)
                .build();
    }
}
